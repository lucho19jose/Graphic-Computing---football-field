<!DOCTYPE html>
<html lang="en">
<head>
  <title>Football Field</title>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
  <link type="text/css" rel="stylesheet" href="main.css">
  <link type="text/css" rel="stylesheet" href="css.css">
  <style>
    body {
      background-color: #cce0ff;
      color: #000;
    }
    a {
      color: #080;
    }
  </style>

</head>

<body>
  <div id="info">Simple Football Field<br />
    Verlet integration with relaxed constraints<br />
  </div>
  <div id="loading">
    <div>
     <div>...loading...</div>
     <div class="progress"><div id="progressbar"></div></div>
   </div>
 </div>

 <script type="module">

   import * as THREE from 'https://threejsfundamentals.org/threejs/resources/threejs/r122/build/three.module.js';

   import Stats from './threejs/stats.module.js';
   import { GUI } from './threejs/dat.gui.module.js';

   import {OrbitControls} from 'https://threejsfundamentals.org/threejs/resources/threejs/r122/examples/jsm/controls/OrbitControls.js';

   // Personaje
   import {GLTFLoader} from 'https://threejsfundamentals.org/threejs/resources/threejs/r122/examples/jsm/loaders/GLTFLoader.js';
   import {SkeletonUtils} from 'https://threejsfundamentals.org/threejs/resources/threejs/r122/examples/jsm/utils/SkeletonUtils.js';


      /*
     * Cloth Simulation using a relaxed constraints solver
     */

    // Suggested Readings

    // Advanced Character Physics by Thomas Jakobsen Character
    // http://freespace.virgin.net/hugo.elias/models/m_cloth.htm
    // http://en.wikipedia.org/wiki/Cloth_modeling
    // http://cg.alexandra.dk/tag/spring-mass-system/
    // Real-time Cloth Animation http://www.darwin3d.com/gamedev/articles/col0599.pdf

    const params = {
      enableWind: true,
      showBall: false,
      togglePins: togglePins
    };

    const DAMPING = 0.03;
    const DRAG = 1 - DAMPING;
    const MASS = 0.1;
    const restDistance = 25;

    const xSegs = 10;
    const ySegs = 10;

    const clothFunction = plane(restDistance * xSegs, restDistance * ySegs);

    const cloth = new Cloth(xSegs, ySegs);

    const GRAVITY = 981 * 1.4;
    const gravity = new THREE.Vector3(0, - GRAVITY, 0).multiplyScalar(MASS);


    const TIMESTEP = 18 / 1000;
    const TIMESTEP_SQ = TIMESTEP * TIMESTEP;

    let pins = [];

    const windForce = new THREE.Vector3(0, 0, 0);

    const ballPosition = new THREE.Vector3(0, - 45, 0);
    const ballSize = 60; //40

    const tmpForce = new THREE.Vector3();


    function plane(width, height) {

      return function (u, v, target) {

        const x = (u - 0.5) * width;
        const y = (v + 0.5) * height;
        const z = 0;

        target.set(x, y, z);

      };

    }

    function Particle(x, y, z, mass) {

      this.position = new THREE.Vector3();
      this.previous = new THREE.Vector3();
      this.original = new THREE.Vector3();
      this.a = new THREE.Vector3(0, 0, 0); // acceleration
      this.mass = mass;
      this.invMass = 1 / mass;
      this.tmp = new THREE.Vector3();
      this.tmp2 = new THREE.Vector3();

      // init

      clothFunction(x, y, this.position); // position
      clothFunction(x, y, this.previous); // previous
      clothFunction(x, y, this.original);

    }

    // Force -> Acceleration

    Particle.prototype.addForce = function (force) {

      this.a.add(
        this.tmp2.copy(force).multiplyScalar(this.invMass)
        );

    };


    // Performs Verlet integration

    Particle.prototype.integrate = function (timesq) {

      const newPos = this.tmp.subVectors(this.position, this.previous);
      newPos.multiplyScalar(DRAG).add(this.position);
      newPos.add(this.a.multiplyScalar(timesq));

      this.tmp = this.previous;
      this.previous = this.position;
      this.position = newPos;

      this.a.set(0, 0, 0);

    };


    const diff = new THREE.Vector3();

    function satisfyConstraints(p1, p2, distance) {

      diff.subVectors(p2.position, p1.position);
      const currentDist = diff.length();
      if (currentDist === 0) return; // prevents division by 0
      const correction = diff.multiplyScalar(1 - distance / currentDist);
      const correctionHalf = correction.multiplyScalar(0.5);
      p1.position.add(correctionHalf);
      p2.position.sub(correctionHalf);

    }


    function Cloth(w, h) {

      w = w || 10;
      h = h || 10;
      this.w = w;
      this.h = h;

      const particles = [];
      const constraints = [];

      // Create particles
      for (let v = 0; v <= h; v++) {

        for (let u = 0; u <= w; u++) {

          particles.push(
            new Particle(u / w, v / h, 0, MASS)
            );

        }

      }

      // Structural

      for (let v = 0; v < h; v++) {

        for (let u = 0; u < w; u++) {

          constraints.push([
            particles[index(u, v)],
            particles[index(u, v + 1)],
            restDistance
            ]);

          constraints.push([
            particles[index(u, v)],
            particles[index(u + 1, v)],
            restDistance
            ]);

        }

      }

      for (let u = w, v = 0; v < h; v++) {

        constraints.push([
          particles[index(u, v)],
          particles[index(u, v + 1)],
          restDistance

          ]);

      }

      for (let v = h, u = 0; u < w; u++) {

        constraints.push([
          particles[index(u, v)],
          particles[index(u + 1, v)],
          restDistance
          ]);

      }


      // While many systems use shear and bend springs,
      // the relaxed constraints model seems to be just fine
      // using structural springs.
      // Shear
      // const diagonalDist = Math.sqrt(restDistance * restDistance * 2);


      // for (v=0;v<h;v++) {
      //  for (u=0;u<w;u++) {

      //    constraints.push([
      //      particles[index(u, v)],
      //      particles[index(u+1, v+1)],
      //      diagonalDist
      //    ]);

      //    constraints.push([
      //      particles[index(u+1, v)],
      //      particles[index(u, v+1)],
      //      diagonalDist
      //    ]);

      //  }
      // }


      this.particles = particles;
      this.constraints = constraints;

      function index(u, v) {

        return u + v * (w + 1);

      }

      this.index = index;

    }

    function simulate(now) {

      const windStrength = Math.cos(now / 7000) * 20 + 40;

      windForce.set(Math.sin(now / 2000), Math.cos(now / 3000), Math.sin(now / 1000));
      windForce.normalize();
      windForce.multiplyScalar(windStrength);

      // Aerodynamics forces

      const particles = cloth.particles;

      if (params.enableWind) {

        let indx;
        const normal = new THREE.Vector3();
        const indices = clothGeometry.index;
        const normals = clothGeometry.attributes.normal;

        for (let i = 0, il = indices.count; i < il; i += 3) {

          for (let j = 0; j < 3; j++) {

            indx = indices.getX(i + j);
            normal.fromBufferAttribute(normals, indx);
            tmpForce.copy(normal).normalize().multiplyScalar(normal.dot(windForce));
            particles[indx].addForce(tmpForce);

          }

        }

      }

      for (let i = 0, il = particles.length; i < il; i++) {

        const particle = particles[i];
        particle.addForce(gravity);

        particle.integrate(TIMESTEP_SQ);

      }

      // Start Constraints

      const constraints = cloth.constraints;
      const il = constraints.length;

      for (let i = 0; i < il; i++) {

        const constraint = constraints[i];
        satisfyConstraints(constraint[0], constraint[1], constraint[2]);

      }

      // Ball Constraints

      ballPosition.z = - Math.sin(now / 600) * 90; //+ 40;
      ballPosition.x = Math.cos(now / 400) * 70;

      if (params.showBall) {

        sphere.visible = true;

        for (let i = 0, il = particles.length; i < il; i++) {

          const particle = particles[i];
          const pos = particle.position;
          diff.subVectors(pos, ballPosition);
          if (diff.length() < ballSize) {

            // collided
            diff.normalize().multiplyScalar(ballSize);
            pos.copy(ballPosition).add(diff);

          }

        }

      } else {

        sphere.visible = false;

      }


      // Floor Constraints

      for (let i = 0, il = particles.length; i < il; i++) {

        const particle = particles[i];
        const pos = particle.position;
        if (pos.y < - 250) {

          pos.y = - 250;

        }

      }

      // Pin Constraints

      for (let i = 0, il = pins.length; i < il; i++) {

        const xy = pins[i];
        const p = particles[xy];
        p.position.copy(p.original);
        p.previous.copy(p.original);

      }


    }

    /* testing cloth simulation */

    const pinsFormation = [];
    pins = [6];

    pinsFormation.push(pins);

    pins = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
    pinsFormation.push(pins);

    pins = [0];
    pinsFormation.push(pins);

    pins = []; // cut the rope ;)
    pinsFormation.push(pins);

    pins = [0, cloth.w]; // classic 2 pins
    pinsFormation.push(pins);

    pins = pinsFormation[1];

    function togglePins() {

      pins = pinsFormation[~ ~(Math.random() * pinsFormation.length)];

    }

    let container, stats;
    let camera, scene, renderer;

    let clothGeometry;
    let sphere;
    let object;

    // Personajes
    const mixers = [];
    let then = 0;

    init();
    animate( 0 );

    function init(){

      container = document.createElement('div');
      document.body.appendChild(container);

      // scene

      scene = new THREE.Scene();
      scene.background = new THREE.Color(0xcce0ff);
      scene.fog = new THREE.Fog(0xcce0ff, 500, 10000);

      // camera

      camera = new THREE.PerspectiveCamera(30, window.innerWidth / window.innerHeight, 1, 10000);
      camera.position.set(3000, 300, 1500); //...near or hear/there

      // lights

      scene.add(new THREE.AmbientLight(0x666666));

      const light = new THREE.DirectionalLight(0xdfebff, 1);//look nice with 0B4C5F
      light.position.set(50, 200, 100);
      light.position.multiplyScalar(1.3);

      light.castShadow = true;

      light.shadow.mapSize.width = 1024;
      light.shadow.mapSize.height = 1024;

      const d = 300;

      light.shadow.camera.left = - d;
      light.shadow.camera.right = d;
      light.shadow.camera.top = d;
      light.shadow.camera.bottom = - d;

      light.shadow.camera.far = 1000;

      scene.add(light);

      // Jugadores
      const manager = new THREE.LoadingManager();
      manager.onLoad = initCharacter;

      const progressbarElem = document.querySelector('#progressbar');
      manager.onProgress = (url, itemsLoaded, itemsTotal) => {
        progressbarElem.style.width = `${itemsLoaded / itemsTotal * 100 | 0}%`;
      };

      const models = {
        mountain0: { url: 'https://threejsfundamentals.org/threejs/resources/models/mountain_landscape/scene.gltf' },
        pug:    { url: 'https://threejsfundamentals.org/threejs/resources/models/animals/Pug.gltf' },
        player1:  { url: 'https://threejsfundamentals.org/threejs/resources/models/knight/KnightCharacter.gltf' },
        player2:  { url: 'https://threejsfundamentals.org/threejs/resources/models/knight/KnightCharacter.gltf' },
        player3:  { url: 'https://threejsfundamentals.org/threejs/resources/models/knight/KnightCharacter.gltf' },
        player4:  { url: 'https://threejsfundamentals.org/threejs/resources/models/knight/KnightCharacter.gltf' },
        player5:  { url: 'https://threejsfundamentals.org/threejs/resources/models/knight/KnightCharacter.gltf' },
        player6:  { url: 'https://threejsfundamentals.org/threejs/resources/models/knight/KnightCharacter.gltf' },
        player7: { url: 'https://threejsfundamentals.org/threejs/resources/models/knight/KnightCharacter.gltf' },
        player8: { url: 'https://threejsfundamentals.org/threejs/resources/models/knight/KnightCharacter.gltf' },
        mountain1: { url: 'https://threejsfundamentals.org/threejs/resources/models/mountain_landscape/scene.gltf' },

        Flamingo1:  { url: 'https://threejsfundamentals.org/threejs/resources/models/flamingo/Flamingo.glb' },
        Flamingo2:    { url: 'https://threejsfundamentals.org/threejs/resources/models/flamingo/Flamingo.glb' },
        Flamingo3:  { url: 'https://threejsfundamentals.org/threejs/resources/models/flamingo/Flamingo.glb' },
      };
      {
        //Cargar archivos gltf
        const gltfLoader = new GLTFLoader(manager);
        for (const model of Object.values(models)) {
          gltfLoader.load(model.url, (gltf) => {
           model.gltf = gltf;
         });
        }
      }

      function prepModelsAndAnimations() {
       Object.values(models).forEach(model => {
        const animsByName = {};
        model.gltf.animations.forEach((clip) => {
         animsByName[clip.name] = clip;
       });
        model.animations = animsByName;
      });
     }

     function initCharacter() {
        // hide the loading bar
        const loadingElem = document.querySelector('#loading');
        loadingElem.style.display = 'none';

        prepModelsAndAnimations();

        Object.values(models).forEach((model, ndx) => {
          const clonedScene = SkeletonUtils.clone(model.gltf.scene);
          const root = new THREE.Object3D();

          root.add(clonedScene);
          scene.add(root);
          //Manda derecha
          if (ndx === 0){
            root.position.x = 0;
            root.position.y = -520;
            root.position.z = -7300;
            // Rotacion
            root.rotation.z = 0;
            root.rotation.y = 8;
            root.rotation.x = 0;
            // Escala
            root.scale.x = 20;
            root.scale.y = 20;
            root.scale.z = 20;
          }
          //posicion de los jugadores
          // Mascota
          else if (ndx === 1) {
            // Posicion
            root.position.x = -1050;
            root.position.y = -200;
            root.position.z = 0;
            // Rotacion
            root.rotation.z = 0;
            root.rotation.y = -80;
            root.rotation.x = 0;
          }
          // Arquero derecho
          else if (ndx === 2) {
            // Posicion
            root.position.x = 0;
            root.position.y = -200;
            root.position.z = -1150;
            // Rotacion
            root.rotation.z = 0;
            root.rotation.y = 0;
            root.rotation.x = 0;
          }
          // jugadores derecho
          else if (ndx > 2 && ndx < 6) {
            // Posicion
            root.position.x = -1350 + ndx * 350;
            root.position.y = -200;
            root.position.z = -400;
            // Rotacion
            root.rotation.z = 0;
            root.rotation.y = 0;
            root.rotation.x = 0;
          }
          // Arquero izquierdo
          else if (ndx === 6) {
            // Posicion
            root.position.x = 0;
            root.position.y = -200;
            root.position.z = 1150;
            // Rotacion
            root.rotation.z = 0;
            root.rotation.y = 198;
            root.rotation.x = 0;
          }
          // Jugadores izquiedo
          else if (ndx > 6 && ndx < 10) {
            // Posicion
            root.position.x = -2650 + ndx * 340;
            root.position.y = -200;
            root.position.z = 400;
            // Rotacion
            root.rotation.z = 0;
            root.rotation.y = 198;
            root.rotation.x = 0;
          }
          //MandaÃ±a del fondo
          else if (ndx === 10){
            root.position.x = -6000;
            root.position.y = -520;
            root.position.z = 0;
            // Rotacion
            root.rotation.z = 0;
            root.rotation.y = 8;
            root.rotation.x = 0;
            // Escala
            root.scale.x = 20;
            root.scale.y = 20;
            root.scale.z = 20;
          }
          // Flamingos
          else if (ndx === 11) {
            // Posicion
            root.position.x = -4000;
            root.position.y = 500;
            root.position.z = 0;
            // Rotacion
            root.rotation.z = 0;
            root.rotation.y = 0;
            root.rotation.x = 0;
          }
          else if (ndx === 12) {
            // Posicion
            root.position.x = -400;
            root.position.y = 500;
            root.position.z = -3000;
            // Rotacion
            root.rotation.z = 0;
            root.rotation.y = 0;
            root.rotation.x = 0;
          }
          else if (ndx === 13) {
            // Posicion
            root.position.x = -2200;
            root.position.y = 500;
            root.position.z = -2300;
            // Rotacion
            root.rotation.z = 0;
            root.rotation.y = 0;
            root.rotation.x = 0;
          }
          if (ndx > 10) {
            // Escala
            root.scale.x = 1;
            root.scale.y = 1;
            root.scale.z = 1;
          }
          // Escala
          if (ndx > 0 && ndx < 10) {
            root.scale.x = 30;
            root.scale.y = 30;
            root.scale.z = 30;
          }
          root.receiveShadow = true;
          root.castShadow = true;

          const mixer = new THREE.AnimationMixer(clonedScene);
          const firstClip = Object.values(model.animations)[0];
          if (ndx > 0 && ndx < 10 || ndx > 10) {
            const action = mixer.clipAction(firstClip);
            action.play();
          }
          mixers.push(mixer);
        });
      }
      //end jugadores

      // cloth material

      const loader = new THREE.TextureLoader();
      const clothTexture = loader.load('textures/circuit_pattern.png');
      clothTexture.anisotropy = 16;

      const clothMaterial = new THREE.MeshLambertMaterial({
        map: clothTexture,
        side: THREE.DoubleSide,
        alphaTest: 0.5
      });

      // cloth geometry

      clothGeometry = new THREE.ParametricBufferGeometry(clothFunction, cloth.w, cloth.h);

      // cloth mesh

      object = new THREE.Mesh(clothGeometry, clothMaterial);
      object.position.set(0, 0, 0);
      object.castShadow = true;
      //scene.add(object);

      object.customDepthMaterial = new THREE.MeshDepthMaterial({
        depthPacking: THREE.RGBADepthPacking,
        map: clothTexture,
        alphaTest: 0.5
      });

      // sphere

      const ballGeo = new THREE.SphereBufferGeometry(ballSize, 32, 16);
      const ballMaterial = new THREE.MeshLambertMaterial();

      sphere = new THREE.Mesh(ballGeo, ballMaterial);
      sphere.castShadow = true;
      sphere.receiveShadow = true;
      sphere.visible = false;
      scene.add(sphere);

      // ground
      //
      const groundTexture = loader.load('textures/grasslight-big.jpg');
      groundTexture.wrapS = groundTexture.wrapT = THREE.RepeatWrapping;
      groundTexture.repeat.set(25, 25);
      groundTexture.anisotropy = 16;
      groundTexture.encoding = THREE.sRGBEncoding;

      const groundMaterial = new THREE.MeshLambertMaterial({ map: groundTexture });

      let mesh = new THREE.Mesh(new THREE.PlaneBufferGeometry(20000, 20000), groundMaterial);
      mesh.position.y = - 250;
      mesh.rotation.x = - Math.PI / 2;
      mesh.receiveShadow = true;
      scene.add(mesh);

      // poles

      const poleGeo = new THREE.BoxBufferGeometry(5, 375, 5);
      const poleMat = new THREE.MeshLambertMaterial();

      mesh = new THREE.Mesh(poleGeo, poleMat);
      mesh.position.x = - 125;
      mesh.position.y = - 62;
      mesh.position.z = -1500;
      mesh.receiveShadow = true;
      mesh.castShadow = true;
      scene.add(mesh);

      mesh = new THREE.Mesh(poleGeo, poleMat);
      mesh.position.x = 125;
      mesh.position.y = - 62;
      mesh.position.z = -1500;
      mesh.receiveShadow = true;
      mesh.castShadow = true;
      scene.add(mesh);

      mesh = new THREE.Mesh(new THREE.BoxBufferGeometry(255, 5, 5), poleMat);
      mesh.position.y = - 250 + (750 / 2);
      mesh.position.x = 0;
      mesh.position.z = -1500;
      mesh.receiveShadow = true;
      mesh.castShadow = true;
      scene.add(mesh);

      //...las patillas del arco
      const gg = new THREE.BoxBufferGeometry(10, 10, 10);
      mesh = new THREE.Mesh(gg, poleMat);
      mesh.position.y = - 250;
      mesh.position.x = 125;
      mesh.position.z = -1500;
      mesh.receiveShadow = true;
      mesh.castShadow = true;
      scene.add(mesh);

      mesh = new THREE.Mesh(gg, poleMat);
      mesh.position.y = - 250;
      mesh.position.x = - 125;
      mesh.position.z = - 1500;
      mesh.receiveShadow = true;
      mesh.castShadow = true;
      scene.add(mesh);

      //...new poles

      const boxito = new THREE.BoxBufferGeometry(5, 375, 5);
      const policito = new THREE.MeshLambertMaterial();

      mesh = new THREE.Mesh(boxito, policito);
      mesh.position.x = -125;
      mesh.position.y = - 62;
      mesh.position.z = 1500
      mesh.receiveShadow = true;
      mesh.castShadow = true;
      scene.add(mesh);

      mesh = new THREE.Mesh(boxito, policito);
      mesh.position.x = 125;
      mesh.position.y = - 62;
      mesh.position.z = 1500
      mesh.receiveShadow = true;
      mesh.castShadow = true;
      scene.add(mesh);

      mesh = new THREE.Mesh(new THREE.BoxBufferGeometry(255, 5, 5), poleMat);
      mesh.position.y = - 250 + (750 / 2);
      mesh.position.x = 0;
      mesh.position.z = 1500;
      mesh.receiveShadow = true;
      mesh.castShadow = true;
      scene.add(mesh);

      const aaa = new THREE.BoxBufferGeometry(10, 10, 10);
      mesh = new THREE.Mesh(aaa, poleMat);
      mesh.position.y = - 250;
      mesh.position.x = 125;
      mesh.position.z = 1500;
      mesh.receiveShadow = true;
      mesh.castShadow = true;
      scene.add(mesh);

      mesh = new THREE.Mesh(aaa, poleMat);
      mesh.position.y = - 250;
      mesh.position.x = - 125;
      mesh.position.z = 1500;
      mesh.receiveShadow = true;
      mesh.castShadow = true;
      scene.add(mesh);
      // renderer
      //... behind original geometry
      const geometry1 = new THREE.BoxGeometry(2000, 200, 50);
      const cubeMaterial = new THREE.MeshBasicMaterial({ color: 0x91622C });
      const materials = [
      new THREE.MeshBasicMaterial({ map: loader.load('textures/img1.jpg') }),
      new THREE.MeshBasicMaterial({ map: loader.load('textures/img1.jpg') }),
      new THREE.MeshBasicMaterial({ map: loader.load('textures/img1.jpg') }),
      new THREE.MeshBasicMaterial({ map: loader.load('textures/img1.jpg') }),
      new THREE.MeshBasicMaterial({ map: loader.load('textures/img1.jpg') }),
      new THREE.MeshBasicMaterial({ map: loader.load('textures/img1.jpg') }),
      ];
      var cube2 = new THREE.Mesh(geometry1, materials);

      cube2.position.x = -100;
      cube2.position.y = -130;
      cube2.position.z = -2000;

      scene.add(cube2);
      //... behind cube
      const geometry2 = new THREE.BoxGeometry(2000, 200, 50);
      const cubeMaterial2 = new THREE.MeshBasicMaterial({ color: 0x91622C });
      var cube3 = new THREE.Mesh(geometry2, cubeMaterial2);

      cube3.position.x = -100;
      cube3.position.y = -130;
      cube3.position.z = 2500;

      scene.add(cube3);
      //... lateral
      const geometry3 = new THREE.BoxGeometry(100, 200, 1700);
      const cubeMaterial3 = new THREE.MeshBasicMaterial({ color: 0x91622C });
      var cube4 = new THREE.Mesh(geometry3, cubeMaterial3);

      cube4.position.x = 2000;
      cube4.position.y = -130;
      cube4.position.z = 1000;

      scene.add(cube4);

      renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setPixelRatio(window.devicePixelRatio);
      renderer.setSize(window.innerWidth, window.innerHeight);

      container.appendChild(renderer.domElement);

      renderer.outputEncoding = THREE.sRGBEncoding;

      renderer.shadowMap.enabled = true;

      //...lines
      const materialLine = new THREE.LineBasicMaterial({
        color: 0xffffff
      });

      const points = [];
      points.push(new THREE.Vector3(- 1000, -250, -1500));
      points.push(new THREE.Vector3(1000, -250, -1500));
      points.push(new THREE.Vector3(1000, -250, 1500));//...lateral left up point
      points.push(new THREE.Vector3(-1000, -250, 1500));
      points.push(new THREE.Vector3(-1000, -250, -1500));//line lateral right
      //...center line
      points.push(new THREE.Vector3(-1000, -250, 0));
      points.push(new THREE.Vector3(1000, -250, 0));
      //area field
      //points.push(new THREE.Vector3(1000, -250, -1500));
      //points.push(new THREE.Vector3(400, -250, -1500));
      //points.push(new THREE.Vector3(400, -250, -1200));
      //points.push(new THREE.Vector3(-400, -250, -1200));
      //points.push(new THREE.Vector3(-400, -250, -1500));

      const geometryLine = new THREE.BufferGeometry().setFromPoints(points);

      const line = new THREE.Line(geometryLine, materialLine);
      scene.add(line);

      //...circle
      const geometryCircle = new THREE.CircleBufferGeometry(100, 32, 90, 45);
      const materialCircle = new THREE.LineBasicMaterial({ color: 0xffff00 });
      const circle = new THREE.Mesh(geometryCircle, materialCircle);
      circle.rotation.x = Math.PI / 2;

      circle.position.x = 0;
      circle.position.y = -130;
      circle.position.z = 1000;
      scene.add(circle);

      //Middle circle
      var segmentCount = 32,
      radius = 100,
      geometrysss = new THREE.Geometry(),
      materialsss = new THREE.LineBasicMaterial({ color: 0xFFFFFF });

      var axis = new THREE.Vector3(0, 1, 0);
      var angle = Math.PI / 2;

      for (var i = 0; i <= segmentCount; i++) {
        var theta = (i / segmentCount) * Math.PI * 2;
        geometrysss.vertices.push(
          new THREE.Vector3(
            Math.cos(theta) * radius,
            Math.sin(theta) * radius,
            1000));
      }

      var circleDraw = new THREE.Line(geometrysss, materialsss)

      circleDraw.position.y = -1250;
      circleDraw.position.z = 0;//.. before 750

      circleDraw.rotateX((Math.PI) * -1 / 2);
      circleDraw.rotateY(0);
      circleDraw.rotateZ(0);

      scene.add(circleDraw);

      //funcion to draw corners
      function corner(positionx, positiony, positionz, rotatex, rotatey, rotatez) {
        var segmentCountCorner1 = 32,
        radiusCorner1 = 100,
        geometryCorner1 = new THREE.Geometry(),
        materialCorner1 = new THREE.LineBasicMaterial({ color: 0xFFFFFF });

        for (var i = 1; i <= segmentCountCorner1; i++) {
          var theta = (i / segmentCountCorner1) * Math.PI / 2;
          geometryCorner1.vertices.push(
            new THREE.Vector3(
              Math.cos(theta) * radiusCorner1,
              Math.sin(theta) * radiusCorner1,
              1000));
        }

        var circleDrawCorner1 = new THREE.Line(geometryCorner1, materialCorner1)

        circleDrawCorner1.position.x = positionx;
        circleDrawCorner1.position.y = positiony;
        circleDrawCorner1.position.z = positionz;

        circleDrawCorner1.rotateX(rotatex);
        circleDrawCorner1.rotateY(rotatey);
        circleDrawCorner1.rotateZ(rotatez);

        scene.add(circleDrawCorner1);
      }
      //drawing corners
      corner(-1000, -1250, -1500, (Math.PI) * -1 / 2, 0, 3 / 2 * Math.PI);
      corner(-1000, -1250, 1500, (Math.PI) * -1 / 2, 0, 0);
      corner(1000, -1250, 1500, (Math.PI) * -1 / 2, 0, 1 / 2 * Math.PI);
      corner(1000, -1250, -1500, (Math.PI) * -1 / 2, 0, Math.PI);
      //corner(800, -1250, -1500, (Math.PI) * -1 / 2, 0, Math.PI);

      //...areas
      function areafield(positionx, positiony, positionz, rotatex, rotatey, rotatez) {
        var segmentCountCorner1 = 32,
        radiusCorner1 = 500,
        geometryCorner1 = new THREE.Geometry(),
        materialCorner1 = new THREE.LineBasicMaterial({ color: 0xFFFFFF });

        for (var i = 1; i <= segmentCountCorner1; i++) {
          var theta = (i / segmentCountCorner1) * (Math.PI + 1 / 40 * Math.PI);
          geometryCorner1.vertices.push(
            new THREE.Vector3(
              Math.cos(theta) * radiusCorner1,
              Math.sin(theta) * radiusCorner1,
              1000));
        }

        var circleDrawCorner1 = new THREE.Line(geometryCorner1, materialCorner1)

        circleDrawCorner1.position.x = positionx;
        circleDrawCorner1.position.y = positiony;
        circleDrawCorner1.position.z = positionz;

        circleDrawCorner1.rotateX(rotatex);
        circleDrawCorner1.rotateY(rotatey);
        circleDrawCorner1.rotateZ(rotatez);

        scene.add(circleDrawCorner1);
      }
      //...areafield circle
      areafield(0, -1250, -1500, (Math.PI) * -1 / 2, 0, 1 * Math.PI - 1 / 30 * Math.PI)
      areafield(0, -1250, 1500, (Math.PI) * -1 / 2, 0, -2 * Math.PI - 1 / 30 * Math.PI)
      //...finish

      //...CylinderGeometry

      const geometryCylinder = new THREE.CylinderGeometry(100, 100, 1, 32);
      const materialCylinder = new THREE.MeshBasicMaterial({ wireframe: false, opacity: 0.5 });
      const cylinder = new THREE.Mesh(geometryCylinder, materialCylinder);
      cylinder.position.x = 0;
      cylinder.position.y = -250;
      cylinder.position.z = 1000;

      //  scene.add(cylinder);

      // controls
      const controls = new OrbitControls(camera, renderer.domElement);
      controls.maxPolarAngle = Math.PI * 0.5;
      controls.minDistance = 1000;
      controls.maxDistance = 7000;

      // performance monitor

      stats = new Stats();
      container.appendChild(stats.dom);

      //

      window.addEventListener('resize', onWindowResize, false);

      //

      const gui = new GUI();
      gui.add(params, 'enableWind').name('Enable wind');
      gui.add(params, 'showBall').name('Show ball');
      gui.add(params, 'togglePins').name('Toggle pins');
      //

      if (typeof TESTING !== 'undefined') {

        for (let i = 0; i < 50; i++) {

          simulate(500 - 10 * i);

        }

      }

    }

    //

    function onWindowResize() {

      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();

      renderer.setSize(window.innerWidth, window.innerHeight);

    }

    //

    function animate( now ) {
      renderJugadores(now);
      requestAnimationFrame( animate );
      simulate(now);
      render();
      stats.update();

    }

    function renderJugadores(now){
      now *= 0.001;  // convert to seconds
      const deltaTime = now - then;
      then = now;

      for (const mixer of mixers) {
        mixer.update(deltaTime);
      }
    }

    function render() {
      const p = cloth.particles;

      for (let i = 0, il = p.length; i < il; i++) {

        const v = p[i].position;

        clothGeometry.attributes.position.setXYZ(i, v.x, v.y, v.z);

      }

      clothGeometry.attributes.position.needsUpdate = true;

      clothGeometry.computeVertexNormals();

      sphere.position.copy(ballPosition);

      renderer.render( scene, camera );
    }

    requestAnimationFrame(render);

  </script>

</body>

</html>