<!DOCTYPE html>
<html lang="en">

<head>
	<title>Football Field</title>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
	<link type="text/css" rel="stylesheet" href="main.css">
	<style>
		body {
			background-color: #cce0ff;
			color: #000;
		}

		a {
			color: #080;
		}
	</style>
</head>

<body>
	<div id="info">Simple Football Field<br />
		Verlet integration with relaxed constraints<br />
	</div>

	<script type="module">

		import * as THREE from './threejs/three.module.js';

		import Stats from './threejs/stats.module.js';
		import { GUI } from './threejs/dat.gui.module.js';

		import { OrbitControls } from './threejs/OrbitControls.js';

		/*
		 * Cloth Simulation using a relaxed constraints solver
		 */

		// Suggested Readings

		// Advanced Character Physics by Thomas Jakobsen Character
		// http://freespace.virgin.net/hugo.elias/models/m_cloth.htm
		// http://en.wikipedia.org/wiki/Cloth_modeling
		// http://cg.alexandra.dk/tag/spring-mass-system/
		// Real-time Cloth Animation http://www.darwin3d.com/gamedev/articles/col0599.pdf

		const params = {
			enableWind: true,
			showBall: false,
			togglePins: togglePins
		};

		const DAMPING = 0.03;
		const DRAG = 1 - DAMPING;
		const MASS = 0.1;
		const restDistance = 25;

		const xSegs = 10;
		const ySegs = 10;

		const clothFunction = plane(restDistance * xSegs, restDistance * ySegs);

		const cloth = new Cloth(xSegs, ySegs);

		const GRAVITY = 981 * 1.4;
		const gravity = new THREE.Vector3(0, - GRAVITY, 0).multiplyScalar(MASS);


		const TIMESTEP = 18 / 1000;
		const TIMESTEP_SQ = TIMESTEP * TIMESTEP;

		let pins = [];

		const windForce = new THREE.Vector3(0, 0, 0);

		const ballPosition = new THREE.Vector3(0, - 45, 0);
		const ballSize = 60; //40

		const tmpForce = new THREE.Vector3();


		function plane(width, height) {

			return function (u, v, target) {

				const x = (u - 0.5) * width;
				const y = (v + 0.5) * height;
				const z = 0;

				target.set(x, y, z);

			};

		}

		function Particle(x, y, z, mass) {

			this.position = new THREE.Vector3();
			this.previous = new THREE.Vector3();
			this.original = new THREE.Vector3();
			this.a = new THREE.Vector3(0, 0, 0); // acceleration
			this.mass = mass;
			this.invMass = 1 / mass;
			this.tmp = new THREE.Vector3();
			this.tmp2 = new THREE.Vector3();

			// init

			clothFunction(x, y, this.position); // position
			clothFunction(x, y, this.previous); // previous
			clothFunction(x, y, this.original);

		}

		// Force -> Acceleration

		Particle.prototype.addForce = function (force) {

			this.a.add(
				this.tmp2.copy(force).multiplyScalar(this.invMass)
			);

		};


		// Performs Verlet integration

		Particle.prototype.integrate = function (timesq) {

			const newPos = this.tmp.subVectors(this.position, this.previous);
			newPos.multiplyScalar(DRAG).add(this.position);
			newPos.add(this.a.multiplyScalar(timesq));

			this.tmp = this.previous;
			this.previous = this.position;
			this.position = newPos;

			this.a.set(0, 0, 0);

		};


		const diff = new THREE.Vector3();

		function satisfyConstraints(p1, p2, distance) {

			diff.subVectors(p2.position, p1.position);
			const currentDist = diff.length();
			if (currentDist === 0) return; // prevents division by 0
			const correction = diff.multiplyScalar(1 - distance / currentDist);
			const correctionHalf = correction.multiplyScalar(0.5);
			p1.position.add(correctionHalf);
			p2.position.sub(correctionHalf);

		}


		function Cloth(w, h) {

			w = w || 10;
			h = h || 10;
			this.w = w;
			this.h = h;

			const particles = [];
			const constraints = [];

			// Create particles
			for (let v = 0; v <= h; v++) {

				for (let u = 0; u <= w; u++) {

					particles.push(
						new Particle(u / w, v / h, 0, MASS)
					);

				}

			}

			// Structural

			for (let v = 0; v < h; v++) {

				for (let u = 0; u < w; u++) {

					constraints.push([
						particles[index(u, v)],
						particles[index(u, v + 1)],
						restDistance
					]);

					constraints.push([
						particles[index(u, v)],
						particles[index(u + 1, v)],
						restDistance
					]);

				}

			}

			for (let u = w, v = 0; v < h; v++) {

				constraints.push([
					particles[index(u, v)],
					particles[index(u, v + 1)],
					restDistance

				]);

			}

			for (let v = h, u = 0; u < w; u++) {

				constraints.push([
					particles[index(u, v)],
					particles[index(u + 1, v)],
					restDistance
				]);

			}


			// While many systems use shear and bend springs,
			// the relaxed constraints model seems to be just fine
			// using structural springs.
			// Shear
			// const diagonalDist = Math.sqrt(restDistance * restDistance * 2);


			// for (v=0;v<h;v++) {
			// 	for (u=0;u<w;u++) {

			// 		constraints.push([
			// 			particles[index(u, v)],
			// 			particles[index(u+1, v+1)],
			// 			diagonalDist
			// 		]);

			// 		constraints.push([
			// 			particles[index(u+1, v)],
			// 			particles[index(u, v+1)],
			// 			diagonalDist
			// 		]);

			// 	}
			// }


			this.particles = particles;
			this.constraints = constraints;

			function index(u, v) {

				return u + v * (w + 1);

			}

			this.index = index;

		}

		function simulate(now) {

			const windStrength = Math.cos(now / 7000) * 20 + 40;

			windForce.set(Math.sin(now / 2000), Math.cos(now / 3000), Math.sin(now / 1000));
			windForce.normalize();
			windForce.multiplyScalar(windStrength);

			// Aerodynamics forces

			const particles = cloth.particles;

			if (params.enableWind) {

				let indx;
				const normal = new THREE.Vector3();
				const indices = clothGeometry.index;
				const normals = clothGeometry.attributes.normal;

				for (let i = 0, il = indices.count; i < il; i += 3) {

					for (let j = 0; j < 3; j++) {

						indx = indices.getX(i + j);
						normal.fromBufferAttribute(normals, indx);
						tmpForce.copy(normal).normalize().multiplyScalar(normal.dot(windForce));
						particles[indx].addForce(tmpForce);

					}

				}

			}

			for (let i = 0, il = particles.length; i < il; i++) {

				const particle = particles[i];
				particle.addForce(gravity);

				particle.integrate(TIMESTEP_SQ);

			}

			// Start Constraints

			const constraints = cloth.constraints;
			const il = constraints.length;

			for (let i = 0; i < il; i++) {

				const constraint = constraints[i];
				satisfyConstraints(constraint[0], constraint[1], constraint[2]);

			}

			// Ball Constraints

			ballPosition.z = - Math.sin(now / 600) * 90; //+ 40;
			ballPosition.x = Math.cos(now / 400) * 70;

			if (params.showBall) {

				sphere.visible = true;

				for (let i = 0, il = particles.length; i < il; i++) {

					const particle = particles[i];
					const pos = particle.position;
					diff.subVectors(pos, ballPosition);
					if (diff.length() < ballSize) {

						// collided
						diff.normalize().multiplyScalar(ballSize);
						pos.copy(ballPosition).add(diff);

					}

				}

			} else {

				sphere.visible = false;

			}


			// Floor Constraints

			for (let i = 0, il = particles.length; i < il; i++) {

				const particle = particles[i];
				const pos = particle.position;
				if (pos.y < - 250) {

					pos.y = - 250;

				}

			}

			// Pin Constraints

			for (let i = 0, il = pins.length; i < il; i++) {

				const xy = pins[i];
				const p = particles[xy];
				p.position.copy(p.original);
				p.previous.copy(p.original);

			}


		}

		/* testing cloth simulation */

		const pinsFormation = [];
		pins = [6];

		pinsFormation.push(pins);

		pins = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
		pinsFormation.push(pins);

		pins = [0];
		pinsFormation.push(pins);

		pins = []; // cut the rope ;)
		pinsFormation.push(pins);

		pins = [0, cloth.w]; // classic 2 pins
		pinsFormation.push(pins);

		pins = pinsFormation[1];

		function togglePins() {

			pins = pinsFormation[~ ~(Math.random() * pinsFormation.length)];

		}

		let container, stats;
		let camera, scene, renderer;

		let clothGeometry;
		let sphere;
		let object;

		init();
		animate(0);

		function init() {

			container = document.createElement('div');
			document.body.appendChild(container);

			// scene

			scene = new THREE.Scene();
			scene.background = new THREE.Color(0xcce0ff);
			scene.fog = new THREE.Fog(0xcce0ff, 500, 10000);

			// camera

			camera = new THREE.PerspectiveCamera(35, window.innerWidth / window.innerHeight, 1, 10000);
			camera.position.set(1000, 500, 1500);

			// lights

			scene.add(new THREE.AmbientLight(0x666666));

			const light = new THREE.DirectionalLight(0xdfebff, 1);//look nice with 0B4C5F
			light.position.set(50, 200, 100);
			light.position.multiplyScalar(1.3);

			light.castShadow = true;

			light.shadow.mapSize.width = 1024;
			light.shadow.mapSize.height = 1024;

			const d = 300;

			light.shadow.camera.left = - d;
			light.shadow.camera.right = d;
			light.shadow.camera.top = d;
			light.shadow.camera.bottom = - d;

			light.shadow.camera.far = 1000;

			scene.add(light);

			// cloth material

			const loader = new THREE.TextureLoader();
			const clothTexture = loader.load('textures/circuit_pattern.png');
			clothTexture.anisotropy = 16;

			const clothMaterial = new THREE.MeshLambertMaterial({
				map: clothTexture,
				side: THREE.DoubleSide,
				alphaTest: 0.5
			});

			// cloth geometry

			clothGeometry = new THREE.ParametricBufferGeometry(clothFunction, cloth.w, cloth.h);

			// cloth mesh

			object = new THREE.Mesh(clothGeometry, clothMaterial);
			object.position.set(0, 0, 0);
			object.castShadow = true;
			//scene.add(object);

			object.customDepthMaterial = new THREE.MeshDepthMaterial({
				depthPacking: THREE.RGBADepthPacking,
				map: clothTexture,
				alphaTest: 0.5
			});

			// sphere

			const ballGeo = new THREE.SphereBufferGeometry(ballSize, 32, 16);
			const ballMaterial = new THREE.MeshLambertMaterial();

			sphere = new THREE.Mesh(ballGeo, ballMaterial);
			sphere.castShadow = true;
			sphere.receiveShadow = true;
			sphere.visible = false;
			scene.add(sphere);

			// ground

			const groundTexture = loader.load('textures/grasslight-big.jpg');
			groundTexture.wrapS = groundTexture.wrapT = THREE.RepeatWrapping;
			groundTexture.repeat.set(25, 25);
			groundTexture.anisotropy = 16;
			groundTexture.encoding = THREE.sRGBEncoding;

			const groundMaterial = new THREE.MeshLambertMaterial({ map: groundTexture });

			let mesh = new THREE.Mesh(new THREE.PlaneBufferGeometry(20000, 20000), groundMaterial);
			mesh.position.y = - 250;
			mesh.rotation.x = - Math.PI / 2;
			mesh.receiveShadow = true;
			scene.add(mesh);

			// poles

			const poleGeo = new THREE.BoxBufferGeometry(5, 375, 5);
			const poleMat = new THREE.MeshLambertMaterial();

			mesh = new THREE.Mesh(poleGeo, poleMat);
			mesh.position.x = - 125;
			mesh.position.y = - 62;
			mesh.position.z = -500;
			mesh.receiveShadow = true;
			mesh.castShadow = true;
			scene.add(mesh);

			mesh = new THREE.Mesh(poleGeo, poleMat);
			mesh.position.x = 125;
			mesh.position.y = - 62;
			mesh.position.z = -500;
			mesh.receiveShadow = true;
			mesh.castShadow = true;
			scene.add(mesh);

			mesh = new THREE.Mesh(new THREE.BoxBufferGeometry(255, 5, 5), poleMat);
			mesh.position.y = - 250 + (750 / 2);
			mesh.position.x = 0;
			mesh.position.z = -500;
			mesh.receiveShadow = true;
			mesh.castShadow = true;
			scene.add(mesh);

			//...las patillas del arco
			const gg = new THREE.BoxBufferGeometry(10, 10, 10);
			mesh = new THREE.Mesh(gg, poleMat);
			mesh.position.y = - 250;
			mesh.position.x = 125;
			mesh.position.z = -500;
			mesh.receiveShadow = true;
			mesh.castShadow = true;
			scene.add(mesh);

			mesh = new THREE.Mesh(gg, poleMat);
			mesh.position.y = - 250;
			mesh.position.x = - 125;
			mesh.position.z = - 500;
			mesh.receiveShadow = true;
			mesh.castShadow = true;
			scene.add(mesh);

			//...new poles

			const boxito = new THREE.BoxBufferGeometry(5, 375, 5);
			const policito = new THREE.MeshLambertMaterial();

			mesh = new THREE.Mesh(boxito, policito);
			mesh.position.x = -125;
			mesh.position.y = - 62;
			mesh.position.z = 2000
			mesh.receiveShadow = true;
			mesh.castShadow = true;
			scene.add(mesh);

			mesh = new THREE.Mesh(boxito, policito);
			mesh.position.x = 125;
			mesh.position.y = - 62;
			mesh.position.z = 2000
			mesh.receiveShadow = true;
			mesh.castShadow = true;
			scene.add(mesh);

			mesh = new THREE.Mesh(new THREE.BoxBufferGeometry(255, 5, 5), poleMat);
			mesh.position.y = - 250 + (750 / 2);
			mesh.position.x = 0;
			mesh.position.z = 2000;
			mesh.receiveShadow = true;
			mesh.castShadow = true;
			scene.add(mesh);

			const aaa = new THREE.BoxBufferGeometry(10, 10, 10);
			mesh = new THREE.Mesh(aaa, poleMat);
			mesh.position.y = - 250;
			mesh.position.x = 125;
			mesh.position.z = 2000;
			mesh.receiveShadow = true;
			mesh.castShadow = true;
			scene.add(mesh);

			mesh = new THREE.Mesh(aaa, poleMat);
			mesh.position.y = - 250;
			mesh.position.x = - 125;
			mesh.position.z = 2000;
			mesh.receiveShadow = true;
			mesh.castShadow = true;
			scene.add(mesh);
			// renderer



			
			//... pared arco oeste
			const geometrypas = new THREE.BoxGeometry(4300, 1000, 80);
			const cubeMateriapas = new THREE.MeshBasicMaterial({ color: 0x91622C });
			const materialspas = [
				new THREE.MeshBasicMaterial({ map: loader.load('textures/textura.png') }),
				new THREE.MeshBasicMaterial({ map: loader.load('textures/textura.png') }),
				new THREE.MeshBasicMaterial({ map: loader.load('textures/textura.png') }),
				new THREE.MeshBasicMaterial({ map: loader.load('textures/textura.png') }),
				new THREE.MeshBasicMaterial({ map: loader.load('textures/textura.png') }),
				new THREE.MeshBasicMaterial({ map: loader.load('textures/textura.png') }),
				

				
			];
			var cubepas = new THREE.Mesh(geometrypas, materialspas);

			cubepas.position.x = 0;
			cubepas.position.y = -130;
			cubepas.position.z = -1000;

			scene.add(cubepas);

			//piso arco oeste
			const geometrypias = new THREE.BoxGeometry(4200, 25, 300);
			const cubeMaterialpias = new THREE.MeshBasicMaterial({ color: 0x91622C });
			const materialspias = [
				new THREE.MeshBasicMaterial({ map: loader.load('textures/texturapiso.png') }),
				new THREE.MeshBasicMaterial({ map: loader.load('textures/texturapiso.png') }),
				new THREE.MeshBasicMaterial({ map: loader.load('textures/texturapiso.png') }),
				new THREE.MeshBasicMaterial({ map: loader.load('textures/texturapiso.png') }),
				new THREE.MeshBasicMaterial({ map: loader.load('textures/texturapiso.png') }),
				new THREE.MeshBasicMaterial({ map: loader.load('textures/texturapiso.png') }),
				new THREE.MeshBasicMaterial({ map: loader.load('textures/texturapiso.png') }),
				

				
			];
			var cubepias = new THREE.Mesh(geometrypias, materialspias);

			cubepias.position.x = 0;
			cubepias.position.y = -250;
			cubepias.position.z = -850;

			scene.add(cubepias);



			const geometrypias1 = new THREE.BoxGeometry(700, 25, 200);
			const cubeMaterialpias1 = new THREE.MeshBasicMaterial({ color: 0x91622C });
			const materialspias1 = [
				new THREE.MeshBasicMaterial({ map: loader.load('textures/texturapiso.png') }),
				new THREE.MeshBasicMaterial({ map: loader.load('textures/texturapiso.png') }),
				new THREE.MeshBasicMaterial({ map: loader.load('textures/texturapiso.png') }),
				new THREE.MeshBasicMaterial({ map: loader.load('textures/texturapiso.png') }),
				new THREE.MeshBasicMaterial({ map: loader.load('textures/texturapiso.png') }),
				new THREE.MeshBasicMaterial({ map: loader.load('textures/texturapiso.png') }),
				new THREE.MeshBasicMaterial({ map: loader.load('textures/texturapiso.png') }),	
				
			];
			var cubepias1 = new THREE.Mesh(geometrypias1, materialspias1);
			cubepias1.position.x = 1800;
			cubepias1.position.y = -260;
			cubepias1.position.z = -600;
			scene.add(cubepias1);


			
			const geometrypias2 = new THREE.BoxGeometry(700, 25, 200);
			const cubeMaterialpias2 = new THREE.MeshBasicMaterial({ color: 0x91622C });
			const materialspias2 = [
				new THREE.MeshBasicMaterial({ map: loader.load('textures/texturapiso.png') }),
				new THREE.MeshBasicMaterial({ map: loader.load('textures/texturapiso.png') }),
				new THREE.MeshBasicMaterial({ map: loader.load('textures/texturapiso.png') }),
				new THREE.MeshBasicMaterial({ map: loader.load('textures/texturapiso.png') }),
				new THREE.MeshBasicMaterial({ map: loader.load('textures/texturapiso.png') }),
				new THREE.MeshBasicMaterial({ map: loader.load('textures/texturapiso.png') }),
				new THREE.MeshBasicMaterial({ map: loader.load('textures/texturapiso.png') }),
				
			];
			var cubepias2 = new THREE.Mesh(geometrypias2, materialspias2);
			cubepias2.position.x = -1800;
			cubepias2.position.y = -260;
			cubepias2.position.z = -600;
			scene.add(cubepias2);






				//... pared arco este
				const geometrypae = new THREE.BoxGeometry(3500, 1000, 80);
				const cubeMateriapae = new THREE.MeshBasicMaterial({ color: 0x91622C });
				const materialspae = [
				new THREE.MeshBasicMaterial({ map: loader.load('textures/textura.png') }),
				new THREE.MeshBasicMaterial({ map: loader.load('textures/textura.png') }),
				new THREE.MeshBasicMaterial({ map: loader.load('textures/textura.png') }),
				new THREE.MeshBasicMaterial({ map: loader.load('textures/textura.png') }),
				new THREE.MeshBasicMaterial({ map: loader.load('textures/textura.png') }),
				new THREE.MeshBasicMaterial({ map: loader.load('textures/textura.png') }),
				

				
			];
			var cubepae = new THREE.Mesh(geometrypae, materialspae);

			cubepae.position.x = 350;
			cubepae.position.y = -250;
			cubepae.position.z = 5000;

			scene.add(cubepae);

			//piso arco este
			const geometrypiae1 = new THREE.BoxGeometry(4200, 25, 2800);
			const cubeMaterialpiae1 = new THREE.MeshBasicMaterial({ color: 0x91622C });
			const materialspiae1 = [
				new THREE.MeshBasicMaterial({ map: loader.load('textures/texturapiso.png') }),
				new THREE.MeshBasicMaterial({ map: loader.load('textures/texturapiso.png') }),
				new THREE.MeshBasicMaterial({ map: loader.load('textures/texturapiso.png') }),
				new THREE.MeshBasicMaterial({ map: loader.load('textures/texturapiso.png') }),
				new THREE.MeshBasicMaterial({ map: loader.load('textures/texturapiso.png') }),
				new THREE.MeshBasicMaterial({ map: loader.load('textures/texturapiso.png') }),
				new THREE.MeshBasicMaterial({ map: loader.load('textures/texturapiso.png') }),
				

				
			];
			var cubepiae1 = new THREE.Mesh(geometrypiae1, materialspiae1);

			cubepiae1.position.x = 0;
			cubepiae1.position.y = -250;
			cubepiae1.position.z = 3600;

			scene.add(cubepiae1);



			
			const geometrypiae2 = new THREE.BoxGeometry(700, 25, 200);
			const cubeMaterialpiae2 = new THREE.MeshBasicMaterial({ color: 0x91622C });
			const materialspiae2 = [
				new THREE.MeshBasicMaterial({ map: loader.load('textures/texturapiso.png') }),
				new THREE.MeshBasicMaterial({ map: loader.load('textures/texturapiso.png') }),
				new THREE.MeshBasicMaterial({ map: loader.load('textures/texturapiso.png') }),
				new THREE.MeshBasicMaterial({ map: loader.load('textures/texturapiso.png') }),
				new THREE.MeshBasicMaterial({ map: loader.load('textures/texturapiso.png') }),
				new THREE.MeshBasicMaterial({ map: loader.load('textures/texturapiso.png') }),
				new THREE.MeshBasicMaterial({ map: loader.load('textures/texturapiso.png') }),	
				
			];
			var cubepiae2 = new THREE.Mesh(geometrypiae2, materialspiae2);
			cubepiae2.position.x = 1800;
			cubepiae2.position.y = -260;
			cubepiae2.position.z = 2100;
			scene.add(cubepiae2);


			
			const geometrypiae3 = new THREE.BoxGeometry(700, 25, 200);
			const cubeMaterialpiae3 = new THREE.MeshBasicMaterial({ color: 0x91622C });
			const materialspiae3 = [
				new THREE.MeshBasicMaterial({ map: loader.load('textures/texturapiso.png') }),
				new THREE.MeshBasicMaterial({ map: loader.load('textures/texturapiso.png') }),
				new THREE.MeshBasicMaterial({ map: loader.load('textures/texturapiso.png') }),
				new THREE.MeshBasicMaterial({ map: loader.load('textures/texturapiso.png') }),
				new THREE.MeshBasicMaterial({ map: loader.load('textures/texturapiso.png') }),
				new THREE.MeshBasicMaterial({ map: loader.load('textures/texturapiso.png') }),
				new THREE.MeshBasicMaterial({ map: loader.load('textures/texturapiso.png') }),
				
			];
			var cubepiae3 = new THREE.Mesh(geometrypiae3, materialspiae3);
			cubepiae3.position.x = -1800;
			cubepiae3.position.y = -260;
			cubepiae3.position.z = 2100;
			scene.add(cubepiae3)

			//... pared izquierdo
			const geometryti = new THREE.BoxGeometry(80, 1000, 6000);
			const cubeMaterialti = new THREE.MeshBasicMaterial({ color: 0x91622C });
			const materialsti = [
				new THREE.MeshBasicMaterial({ map: loader.load('textures/textura.png') }),
				new THREE.MeshBasicMaterial({ map: loader.load('textures/textura.png') }),
				new THREE.MeshBasicMaterial({ map: loader.load('textures/textura.png') }),
				new THREE.MeshBasicMaterial({ map: loader.load('textures/textura.png') }),
				new THREE.MeshBasicMaterial({ map: loader.load('textures/textura.png') }),
				new THREE.MeshBasicMaterial({ map: loader.load('textures/textura.png') }),
				

				
			];
			var cubeti = new THREE.Mesh(geometryti, materialsti);

			cubeti.position.x = 2110;
			cubeti.position.y = 90;
			cubeti.position.z = 2000;

			scene.add(cubeti);

			//... pared derecho
			const geometrytd = new THREE.BoxGeometry(80, 1000, 6000);
			const cubeMaterialtd = new THREE.MeshBasicMaterial({ color: 0x91622C });
			const materialstd = [
				new THREE.MeshBasicMaterial({ map: loader.load('textures/textura.png') }),
				new THREE.MeshBasicMaterial({ map: loader.load('textures/textura.png') }),
				new THREE.MeshBasicMaterial({ map: loader.load('textures/textura.png') }),
				new THREE.MeshBasicMaterial({ map: loader.load('textures/textura.png') }),
				new THREE.MeshBasicMaterial({ map: loader.load('textures/textura.png') }),
				new THREE.MeshBasicMaterial({ map: loader.load('textures/textura.png') }),
				

				
			];
			var cubetd = new THREE.Mesh(geometrytd, materialstd);

			cubetd.position.x = -2110;
			cubetd.position.y = 90;
			cubetd.position.z = 2000;

			scene.add(cubetd);


			
			/*
			//... behind cube
			const geometry2 = new THREE.BoxGeometry(2000, 200, 50);
			const cubeMaterial2 = new THREE.MeshBasicMaterial({ color: 0x91622C });
			var cube3 = new THREE.Mesh(geometry2, cubeMaterial2);

			cube3.position.x = -100;
			cube3.position.y = -130;
			cube3.position.z = 2500;

			scene.add(cube3);

			*/
			//... lateral izquierdo
			//lateral izquierdo 0
			const geometryi0 = new THREE.BoxGeometry(300, 25, 3500);
			const cubeMateriali0 = new THREE.MeshBasicMaterial({ color: 0x91622C });
			const materialsi0 = [
				new THREE.MeshBasicMaterial({ map: loader.load('textures/texturapiso.png') }),
				new THREE.MeshBasicMaterial({ map: loader.load('textures/texturapiso.png') }),
				new THREE.MeshBasicMaterial({ map: loader.load('textures/texturapiso.png') }),
				new THREE.MeshBasicMaterial({ map: loader.load('textures/texturapiso.png') }),
				new THREE.MeshBasicMaterial({ map: loader.load('textures/texturapiso.png') }),
				new THREE.MeshBasicMaterial({ map: loader.load('textures/texturapiso.png') }),
				new THREE.MeshBasicMaterial({ map: loader.load('textures/texturapiso.png') }),
				

				
			];
			var cubei0 = new THREE.Mesh(geometryi0, materialsi0);

			cubei0.position.x = 1300;
			cubei0.position.y = -260;
			cubei0.position.z = 750;

			scene.add(cubei0);

//-----------------------------------------------------------------------------------------------------------
	

var geometryy =new THREE.CircleGeometry( 1000, 32 );

var materialy = new THREE.MeshBasicMaterial( { color: 0x00ff00 } );
var cubey = new THREE.Mesh( geometryy, materialy );
scene.add( cubey );		
  /*
		const geometryq = new THREE.CylinderGeometry(
               radiusTop = 100,
               radiusBotton = 100, height = 200,
               radiusSegments = 100,
               heightSegments = 1,
               openEnded = false);

		const materialq = new THREE.MeshBasicMaterial({ color: 0xFDE915 });

            
			var meshq = new THREE.Mesh(geometryq,materialq);
			
            scene.add(meshq);
   
*/
/*const curve = new THREE.EllipseCurve(
	-40, -40,            // ax, aY
	200, 200,           // xRadius, yRadius
	0, 2* Math.PI,  // aStartAngle, aEndAngle
	false,            // aClockwise
	0               // aRotation
);


const pointsw = curve.getPoints( 6 );

const geometryw = new THREE.BufferGeometry().setFromPoints( pointsw );

const materialw = new THREE.LineBasicMaterial( { color : 0xff0000 } );

// Create the final object to add to the scene
const ellipsew = new THREE.Line( geometryw, materialw);
ellipsew.position.x = 0;
ellipsew.position.y = 500;
ellipsew.position.z = -1200;

scene.add(ellipsew);

*/

//----------------------------------------------------------------------------------------------------------------------------------

			//lateral izquierdo 1
			const geometryi1 = new THREE.BoxGeometry(100, 100, 2500);
			const cubeMateriali1 = new THREE.MeshBasicMaterial({ color: 0xFDE915 });
			var cubei1 = new THREE.Mesh(geometryi1, cubeMateriali1);

			cubei1.position.x = 1500;
			cubei1.position.y = -230;
			cubei1.position.z = 750;

			scene.add(cubei1);

			//lateral izquierdo 2
			const geometryi2 = new THREE.BoxGeometry(100, 150, 2500);
			const cubeMateriali2 = new THREE.MeshBasicMaterial({ color: 0xFDE915 });
			var cubei2 = new THREE.Mesh(geometryi2, cubeMateriali2);

			cubei2.position.x = 1600;
			cubei2.position.y = -190;
			cubei2.position.z = 750;

			scene.add(cubei2);

			//lateral izquierdo 3
			const geometryi3 = new THREE.BoxGeometry(100, 200, 2500);
			const cubeMateriali3 = new THREE.MeshBasicMaterial({ color: 0xEB671D });
			var cubei3 = new THREE.Mesh(geometryi3, cubeMateriali3);

			cubei3.position.x = 1700;
			cubei3.position.y = -150;
			cubei3.position.z = 750;

			scene.add(cubei3);

			//lateral izquierdo 4
			const geometryi4 = new THREE.BoxGeometry(100, 250, 2500);
			const cubeMateriali4 = new THREE.MeshBasicMaterial({ color: 0xEB671D });
			var cubei4 = new THREE.Mesh(geometryi4, cubeMateriali4);

			cubei4.position.x = 1800;
			cubei4.position.y = -130;
			cubei4.position.z = 750;

			scene.add(cubei4);

			//lateral izquierdo 5
			const geometryi5 = new THREE.BoxGeometry(100, 300, 2500);
			const cubeMateriali5 = new THREE.MeshBasicMaterial({ color: 0xE21618});
			var cubei5 = new THREE.Mesh(geometryi5, cubeMateriali5);

			cubei5.position.x = 1900;
			cubei5.position.y = -110;
			cubei5.position.z = 750;

			scene.add(cubei5);

			//lateral izquierdo 6
			const geometryi6 = new THREE.BoxGeometry(100, 350, 2500);
			const cubeMateriali6 = new THREE.MeshBasicMaterial({ color: 0xE21618});
			var cubei6 = new THREE.Mesh(geometryi6, cubeMateriali6);

			cubei6.position.x = 2000;
			cubei6.position.y = -90;
			cubei6.position.z = 750;

			scene.add(cubei6);


			//lateral derecho
				//lateral derecho 0
				const geometryd0 = new THREE.BoxGeometry(300,25, 3500);
			const cubeMateriald0 = new THREE.MeshBasicMaterial({ color: 0x91622C });
			const materialsd0 = [
				new THREE.MeshBasicMaterial({ map: loader.load('textures/texturapiso.png') }),
				new THREE.MeshBasicMaterial({ map: loader.load('textures/texturapiso.png') }),
				new THREE.MeshBasicMaterial({ map: loader.load('textures/texturapiso.png') }),
				new THREE.MeshBasicMaterial({ map: loader.load('textures/texturapiso.png') }),
				new THREE.MeshBasicMaterial({ map: loader.load('textures/texturapiso.png') }),
				new THREE.MeshBasicMaterial({ map: loader.load('textures/texturapiso.png') }),
				new THREE.MeshBasicMaterial({ map: loader.load('textures/texturapiso.png') }),
				

				
			];
			var cubed0 = new THREE.Mesh(geometryd0, materialsd0);

			cubed0.position.x = -1300;
			cubed0.position.y = -260;
			cubed0.position.z = 750;

			scene.add(cubed0);

			//lateral derecho 1
			const geometryd1 = new THREE.BoxGeometry(100, 100, 2500);
			const cubeMateriald1 = new THREE.MeshBasicMaterial({ color: 0xFDE915 });
			var cubed1 = new THREE.Mesh(geometryd1, cubeMateriald1);

			cubed1.position.x = -1500;
			cubed1.position.y = -230;
			cubed1.position.z = 750;

			scene.add(cubed1);

			//lateral derecho 2
			const geometryd2 = new THREE.BoxGeometry(100, 150, 2500);
			const cubeMateriald2 = new THREE.MeshBasicMaterial({ color: 0xFDE915 });
			var cubed2 = new THREE.Mesh(geometryd2, cubeMateriald2);

			cubed2.position.x = -1600;
			cubed2.position.y = -190;
			cubed2.position.z = 750;

			scene.add(cubed2);

			//lateral derecho 3
			const geometryd3 = new THREE.BoxGeometry(100, 200, 2500);
			const cubeMateriald3 = new THREE.MeshBasicMaterial({ color: 0xEB671D });
			var cubed3 = new THREE.Mesh(geometryd3, cubeMateriald3);

			cubed3.position.x = -1700;
			cubed3.position.y = -150;
			cubed3.position.z = 750;

			scene.add(cubed3);

			//lateral derecho 4
			const geometryd4 = new THREE.BoxGeometry(100, 250, 2500);
			const cubeMateriald4 = new THREE.MeshBasicMaterial({ color: 0xEB671D });
			var cubed4 = new THREE.Mesh(geometryd4, cubeMateriald4);

			cubed4.position.x = -1800;
			cubed4.position.y = -130;
			cubed4.position.z = 750;

			scene.add(cubed4);

			//lateral derecho 5
			const geometryd5 = new THREE.BoxGeometry(100, 300, 2500);
			const cubeMateriald5 = new THREE.MeshBasicMaterial({ color: 0xE21618});
			var cubed5 = new THREE.Mesh(geometryd5, cubeMateriald5);

			cubed5.position.x = -1900;
			cubed5.position.y = -110;
			cubed5.position.z = 750;

			scene.add(cubed5);

			//lateral derecho 6
			const geometryd6 = new THREE.BoxGeometry(100, 350, 2500);
			const cubeMateriald6 = new THREE.MeshBasicMaterial({ color: 0xE21618});
			var cubed6 = new THREE.Mesh(geometryd6, cubeMateriald6);

			cubed6.position.x = -2000;
			cubed6.position.y = -90;
			cubed6.position.z = 750;

			scene.add(cubed6);


			renderer = new THREE.WebGLRenderer({ antialias: true });
			renderer.setPixelRatio(window.devicePixelRatio);
			renderer.setSize(window.innerWidth, window.innerHeight);

			container.appendChild(renderer.domElement);

			renderer.outputEncoding = THREE.sRGBEncoding;

			renderer.shadowMap.enabled = true;

			
			

			//...lines
			const materialLine = new THREE.LineBasicMaterial({
				color: 0xffffff
			});

			const points = [];
			points.push(new THREE.Vector3(- 1000, -250, -500));
			points.push(new THREE.Vector3(1000, -250, -500));
			points.push(new THREE.Vector3(1000, -250, 2000));//...lateral derecho
			points.push(new THREE.Vector3(-1000, -250, 2000));
			points.push(new THREE.Vector3(-1000, -250, -500));//line lateral right
			//...center line
			points.push(new THREE.Vector3(-1000, -250, 750));
			points.push(new THREE.Vector3(1000, -250, 750));

			const geometryLine = new THREE.BufferGeometry().setFromPoints(points);

			const line = new THREE.Line(geometryLine, materialLine);
			scene.add(line);

			//...circle
			const geometryCircle = new THREE.CircleBufferGeometry(100, 32, 90, 45);
			const materialCircle = new THREE.LineBasicMaterial({ color: 0xffff00 });
			const circle = new THREE.Mesh(geometryCircle, materialCircle);
			circle.rotation.x = Math.PI / 2;

			circle.position.x = 0;
			circle.position.y = -130;
			circle.position.z = 1000;
			scene.add(circle);

			//Middle circle
			var segmentCount = 32,
				radius = 100,
				geometrysss = new THREE.Geometry(),
				materialsss = new THREE.LineBasicMaterial({ color: 0xFFFFFF });

			var axis = new THREE.Vector3(0, 1, 0);
			var angle = Math.PI / 2;

			for (var i = 0; i <= segmentCount; i++) {
				var theta = (i / segmentCount) * Math.PI * 2;
				geometrysss.vertices.push(
					new THREE.Vector3(
						Math.cos(theta) * radius,
						Math.sin(theta) * radius,
						1000));
			}

			var circleDraw = new THREE.Line(geometrysss, materialsss)

			circleDraw.position.y = -1250;
			circleDraw.position.z = 750;

			circleDraw.rotateX((Math.PI) * -1 / 2);
			circleDraw.rotateY(0);
			circleDraw.rotateZ(0);

			scene.add(circleDraw);

			//corner circle/4 lefth-down 
			/* 	const geometryC = new THREE.CircleGeometry(100, 32, Math.PI, (Math.PI) * 1 / 2);
				const materialC = new THREE.MeshLambertMaterial({ wireframe: false, opacity: 0.5 });
				const circleC = new THREE.Mesh(geometryC, materialC);
				circleC.position.x = 1000;
				circleC.position.z = 0;
				circleC.position.y = -249;
				circleC.rotateX((Math.PI) * -1 / 2);
				circleC.rotateY(0);
				circleC.rotateZ(0);
	
				scene.add(circleC); */

			//corner circle/4 right-down
			//funcion to draw corners 
			function corner(positionx, positiony, positionz, rotatex, rotatey, rotatez) {
				var segmentCountCorner1 = 32,
					radiusCorner1 = 100,
					geometryCorner1 = new THREE.Geometry(),
					materialCorner1 = new THREE.LineBasicMaterial({ color: 0xFFFFFF });

				for (var i = 1; i <= segmentCountCorner1; i++) {
					var theta = (i / segmentCountCorner1) * Math.PI / 2;
					geometryCorner1.vertices.push(
						new THREE.Vector3(
							Math.cos(theta) * radiusCorner1,
							Math.sin(theta) * radiusCorner1,
							1000));
				}

				var circleDrawCorner1 = new THREE.Line(geometryCorner1, materialCorner1)

				circleDrawCorner1.position.x = positionx;
				circleDrawCorner1.position.y = positiony;
				circleDrawCorner1.position.z = positionz;

				circleDrawCorner1.rotateX(rotatex);
				circleDrawCorner1.rotateY(rotatey);
				circleDrawCorner1.rotateZ(rotatez);

				scene.add(circleDrawCorner1);
			}
			//drawing corners
			corner(-1000, -1250, -500, (Math.PI) * -1 / 2, 0, 3 / 2 * Math.PI);
			corner(-1000, -1250, 2000, (Math.PI) * -1 / 2, 0, 0);
			corner(1000, -1250, 2000, (Math.PI) * -1 / 2, 0, 1 / 2 * Math.PI);
			corner(1000, -1250, -500, (Math.PI) * -1 / 2, 0, Math.PI);
			//...finish

			//...CylinderGeometry

			const geometryCylinder = new THREE.CylinderGeometry(100, 100, 1, 32);
			const materialCylinder = new THREE.MeshBasicMaterial({ wireframe: false, opacity: 0.5 });
			const cylinder = new THREE.Mesh(geometryCylinder, materialCylinder);
			cylinder.position.x = 0;
			cylinder.position.y = -250;
			cylinder.position.z = 1000;

			//	scene.add(cylinder);

			// controls
			const controls = new OrbitControls(camera, renderer.domElement);
			controls.maxPolarAngle = Math.PI * 0.5;
			controls.minDistance = 1000;
			controls.maxDistance = 10000;

			// performance monitor

			stats = new Stats();
			container.appendChild(stats.dom);

			//

			window.addEventListener('resize', onWindowResize, false);

			//

			const gui = new GUI();
			gui.add(params, 'enableWind').name('Enable wind');
			gui.add(params, 'showBall').name('Show ball');
			gui.add(params, 'togglePins').name('Toggle pins');
			//

			if (typeof TESTING !== 'undefined') {

				for (let i = 0; i < 50; i++) {

					simulate(500 - 10 * i);

				}

			}

		}

		//

		function onWindowResize() {

			camera.aspect = window.innerWidth / window.innerHeight;
			camera.updateProjectionMatrix();

			renderer.setSize(window.innerWidth, window.innerHeight);

		}

		//

		function animate(now) {

			requestAnimationFrame(animate);
			simulate(now);
			render();
			stats.update();

		}

		function render() {

			const p = cloth.particles;

			for (let i = 0, il = p.length; i < il; i++) {

				const v = p[i].position;

				clothGeometry.attributes.position.setXYZ(i, v.x, v.y, v.z);

			}

			clothGeometry.attributes.position.needsUpdate = true;

			clothGeometry.computeVertexNormals();

			sphere.position.copy(ballPosition);

			renderer.render(scene, camera);

		}

	</script>
</body>

</html>